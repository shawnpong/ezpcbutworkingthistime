{"ast":null,"code":"\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"C:/Users/pongster/Documents/ezpcbutworkingthistime/FRONTEND/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = gatherSequenceExpressions;\nvar _getBindingIdentifiers = require(\"../retrievers/getBindingIdentifiers\");\nvar _generated = require(\"../validators/generated\");\nvar _generated2 = require(\"../builders/generated\");\nvar _cloneNode = require(\"../clone/cloneNode\");\nfunction gatherSequenceExpressions(nodes, scope, declars) {\n  var exprs = [];\n  var ensureLastUndefined = true;\n  var _iterator = _createForOfIteratorHelper(nodes),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var node = _step.value;\n      if (!(0, _generated.isEmptyStatement)(node)) {\n        ensureLastUndefined = false;\n      }\n      if ((0, _generated.isExpression)(node)) {\n        exprs.push(node);\n      } else if ((0, _generated.isExpressionStatement)(node)) {\n        exprs.push(node.expression);\n      } else if ((0, _generated.isVariableDeclaration)(node)) {\n        if (node.kind !== \"var\") return;\n        var _iterator2 = _createForOfIteratorHelper(node.declarations),\n          _step2;\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var declar = _step2.value;\n            var bindings = (0, _getBindingIdentifiers.default)(declar);\n            for (var _i = 0, _Object$keys = Object.keys(bindings); _i < _Object$keys.length; _i++) {\n              var key = _Object$keys[_i];\n              declars.push({\n                kind: node.kind,\n                id: (0, _cloneNode.default)(bindings[key])\n              });\n            }\n            if (declar.init) {\n              exprs.push((0, _generated2.assignmentExpression)(\"=\", declar.id, declar.init));\n            }\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n        ensureLastUndefined = true;\n      } else if ((0, _generated.isIfStatement)(node)) {\n        var consequent = node.consequent ? gatherSequenceExpressions([node.consequent], scope, declars) : scope.buildUndefinedNode();\n        var alternate = node.alternate ? gatherSequenceExpressions([node.alternate], scope, declars) : scope.buildUndefinedNode();\n        if (!consequent || !alternate) return;\n        exprs.push((0, _generated2.conditionalExpression)(node.test, consequent, alternate));\n      } else if ((0, _generated.isBlockStatement)(node)) {\n        var body = gatherSequenceExpressions(node.body, scope, declars);\n        if (!body) return;\n        exprs.push(body);\n      } else if ((0, _generated.isEmptyStatement)(node)) {\n        if (nodes.indexOf(node) === 0) {\n          ensureLastUndefined = true;\n        }\n      } else {\n        return;\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  if (ensureLastUndefined) {\n    exprs.push(scope.buildUndefinedNode());\n  }\n  if (exprs.length === 1) {\n    return exprs[0];\n  } else {\n    return (0, _generated2.sequenceExpression)(exprs);\n  }\n}","map":{"version":3,"names":["_getBindingIdentifiers","require","_generated","_generated2","_cloneNode","gatherSequenceExpressions","nodes","scope","declars","exprs","ensureLastUndefined","_iterator","_createForOfIteratorHelper","_step","s","n","done","node","value","isEmptyStatement","isExpression","push","isExpressionStatement","expression","isVariableDeclaration","kind","_iterator2","declarations","_step2","declar","bindings","default","_i","_Object$keys","Object","keys","length","key","id","init","assignmentExpression","err","e","f","isIfStatement","consequent","buildUndefinedNode","alternate","conditionalExpression","test","isBlockStatement","body","indexOf","sequenceExpression"],"sources":["C:\\Users\\pongster\\Documents\\ezpcbutworkingthistime\\FRONTEND\\node_modules\\@babel\\types\\src\\converters\\gatherSequenceExpressions.ts"],"sourcesContent":["import getBindingIdentifiers from \"../retrievers/getBindingIdentifiers\";\nimport {\n  isExpression,\n  isExpressionStatement,\n  isVariableDeclaration,\n  isIfStatement,\n  isBlockStatement,\n  isEmptyStatement,\n} from \"../validators/generated\";\nimport {\n  sequenceExpression,\n  assignmentExpression,\n  conditionalExpression,\n} from \"../builders/generated\";\nimport cloneNode from \"../clone/cloneNode\";\nimport type * as t from \"..\";\nimport type { Scope } from \"@babel/traverse\";\n\nexport type DeclarationInfo = {\n  kind: t.VariableDeclaration[\"kind\"];\n  id: t.Identifier;\n};\n\nexport default function gatherSequenceExpressions(\n  nodes: ReadonlyArray<t.Node>,\n  scope: Scope,\n  declars: Array<DeclarationInfo>,\n) {\n  const exprs: t.Expression[] = [];\n  let ensureLastUndefined = true;\n\n  for (const node of nodes) {\n    // if we encounter emptyStatement before a non-emptyStatement\n    // we want to disregard that\n    if (!isEmptyStatement(node)) {\n      ensureLastUndefined = false;\n    }\n\n    if (isExpression(node)) {\n      exprs.push(node);\n    } else if (isExpressionStatement(node)) {\n      exprs.push(node.expression);\n    } else if (isVariableDeclaration(node)) {\n      if (node.kind !== \"var\") return; // bailed\n\n      for (const declar of node.declarations) {\n        const bindings = getBindingIdentifiers(declar);\n        for (const key of Object.keys(bindings)) {\n          declars.push({\n            kind: node.kind,\n            id: cloneNode(bindings[key]),\n          });\n        }\n\n        if (declar.init) {\n          exprs.push(assignmentExpression(\"=\", declar.id, declar.init));\n        }\n      }\n\n      ensureLastUndefined = true;\n    } else if (isIfStatement(node)) {\n      const consequent = node.consequent\n        ? gatherSequenceExpressions([node.consequent], scope, declars)\n        : scope.buildUndefinedNode();\n      const alternate = node.alternate\n        ? gatherSequenceExpressions([node.alternate], scope, declars)\n        : scope.buildUndefinedNode();\n      if (!consequent || !alternate) return; // bailed\n\n      exprs.push(conditionalExpression(node.test, consequent, alternate));\n    } else if (isBlockStatement(node)) {\n      const body = gatherSequenceExpressions(node.body, scope, declars);\n      if (!body) return; // bailed\n\n      exprs.push(body);\n    } else if (isEmptyStatement(node)) {\n      // empty statement so ensure the last item is undefined if we're last\n      // checks if emptyStatement is first\n      if (nodes.indexOf(node) === 0) {\n        ensureLastUndefined = true;\n      }\n    } else {\n      // bailed, we can't turn this statement into an expression\n      return;\n    }\n  }\n\n  if (ensureLastUndefined) {\n    exprs.push(scope.buildUndefinedNode());\n  }\n\n  if (exprs.length === 1) {\n    return exprs[0];\n  } else {\n    return sequenceExpression(exprs);\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}