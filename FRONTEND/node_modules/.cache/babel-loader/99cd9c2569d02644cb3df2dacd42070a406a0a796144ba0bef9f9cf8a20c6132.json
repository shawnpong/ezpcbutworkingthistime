{"ast":null,"code":"\"use strict\";\n\nvar _defineProperty = require(\"C:/Users/pongster/Documents/ezpcbutworkingthistime/FRONTEND/node_modules/@babel/runtime/helpers/defineProperty.js\").default;\nvar _utils = require(\"./utils\");\nvar _core = require(\"./core\");\nvar _is = require(\"../validators/is\");\nvar defineType = (0, _utils.defineAliasedType)(\"TypeScript\");\nvar bool = (0, _utils.assertValueType)(\"boolean\");\nvar tSFunctionTypeAnnotationCommon = function tSFunctionTypeAnnotationCommon() {\n  return {\n    returnType: {\n      validate: (0, _utils.assertNodeType)(\"TSTypeAnnotation\", \"Noop\"),\n      optional: true\n    },\n    typeParameters: {\n      validate: (0, _utils.assertNodeType)(\"TSTypeParameterDeclaration\", \"Noop\"),\n      optional: true\n    }\n  };\n};\ndefineType(\"TSParameterProperty\", {\n  aliases: [\"LVal\"],\n  visitor: [\"parameter\"],\n  fields: {\n    accessibility: {\n      validate: (0, _utils.assertOneOf)(\"public\", \"private\", \"protected\"),\n      optional: true\n    },\n    readonly: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    parameter: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\", \"AssignmentPattern\")\n    },\n    override: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    decorators: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n      optional: true\n    }\n  }\n});\ndefineType(\"TSDeclareFunction\", {\n  aliases: [\"Statement\", \"Declaration\"],\n  visitor: [\"id\", \"typeParameters\", \"params\", \"returnType\"],\n  fields: Object.assign({}, (0, _core.functionDeclarationCommon)(), tSFunctionTypeAnnotationCommon())\n});\ndefineType(\"TSDeclareMethod\", {\n  visitor: [\"decorators\", \"key\", \"typeParameters\", \"params\", \"returnType\"],\n  fields: Object.assign({}, (0, _core.classMethodOrDeclareMethodCommon)(), tSFunctionTypeAnnotationCommon())\n});\ndefineType(\"TSQualifiedName\", {\n  aliases: [\"TSEntityName\"],\n  visitor: [\"left\", \"right\"],\n  fields: {\n    left: (0, _utils.validateType)(\"TSEntityName\"),\n    right: (0, _utils.validateType)(\"Identifier\")\n  }\n});\nvar signatureDeclarationCommon = function signatureDeclarationCommon() {\n  var _ref;\n  return _ref = {\n    typeParameters: (0, _utils.validateOptionalType)(\"TSTypeParameterDeclaration\")\n  }, _defineProperty(_ref, \"parameters\", (0, _utils.validateArrayOfType)([\"Identifier\", \"RestElement\"])), _defineProperty(_ref, \"typeAnnotation\", (0, _utils.validateOptionalType)(\"TSTypeAnnotation\")), _ref;\n};\nvar callConstructSignatureDeclaration = {\n  aliases: [\"TSTypeElement\"],\n  visitor: [\"typeParameters\", \"parameters\", \"typeAnnotation\"],\n  fields: signatureDeclarationCommon()\n};\ndefineType(\"TSCallSignatureDeclaration\", callConstructSignatureDeclaration);\ndefineType(\"TSConstructSignatureDeclaration\", callConstructSignatureDeclaration);\nvar namedTypeElementCommon = function namedTypeElementCommon() {\n  return {\n    key: (0, _utils.validateType)(\"Expression\"),\n    computed: {\n      default: false\n    },\n    optional: (0, _utils.validateOptional)(bool)\n  };\n};\ndefineType(\"TSPropertySignature\", {\n  aliases: [\"TSTypeElement\"],\n  visitor: [\"key\", \"typeAnnotation\", \"initializer\"],\n  fields: Object.assign({}, namedTypeElementCommon(), {\n    readonly: (0, _utils.validateOptional)(bool),\n    typeAnnotation: (0, _utils.validateOptionalType)(\"TSTypeAnnotation\"),\n    initializer: (0, _utils.validateOptionalType)(\"Expression\"),\n    kind: {\n      validate: (0, _utils.assertOneOf)(\"get\", \"set\")\n    }\n  })\n});\ndefineType(\"TSMethodSignature\", {\n  aliases: [\"TSTypeElement\"],\n  visitor: [\"key\", \"typeParameters\", \"parameters\", \"typeAnnotation\"],\n  fields: Object.assign({}, signatureDeclarationCommon(), namedTypeElementCommon(), {\n    kind: {\n      validate: (0, _utils.assertOneOf)(\"method\", \"get\", \"set\")\n    }\n  })\n});\ndefineType(\"TSIndexSignature\", {\n  aliases: [\"TSTypeElement\"],\n  visitor: [\"parameters\", \"typeAnnotation\"],\n  fields: {\n    readonly: (0, _utils.validateOptional)(bool),\n    static: (0, _utils.validateOptional)(bool),\n    parameters: (0, _utils.validateArrayOfType)(\"Identifier\"),\n    typeAnnotation: (0, _utils.validateOptionalType)(\"TSTypeAnnotation\")\n  }\n});\nvar tsKeywordTypes = [\"TSAnyKeyword\", \"TSBooleanKeyword\", \"TSBigIntKeyword\", \"TSIntrinsicKeyword\", \"TSNeverKeyword\", \"TSNullKeyword\", \"TSNumberKeyword\", \"TSObjectKeyword\", \"TSStringKeyword\", \"TSSymbolKeyword\", \"TSUndefinedKeyword\", \"TSUnknownKeyword\", \"TSVoidKeyword\"];\nfor (var _i = 0, _tsKeywordTypes = tsKeywordTypes; _i < _tsKeywordTypes.length; _i++) {\n  var type = _tsKeywordTypes[_i];\n  defineType(type, {\n    aliases: [\"TSType\", \"TSBaseType\"],\n    visitor: [],\n    fields: {}\n  });\n}\ndefineType(\"TSThisType\", {\n  aliases: [\"TSType\", \"TSBaseType\"],\n  visitor: [],\n  fields: {}\n});\nvar fnOrCtrBase = {\n  aliases: [\"TSType\"],\n  visitor: [\"typeParameters\", \"parameters\", \"typeAnnotation\"]\n};\ndefineType(\"TSFunctionType\", Object.assign({}, fnOrCtrBase, {\n  fields: signatureDeclarationCommon()\n}));\ndefineType(\"TSConstructorType\", Object.assign({}, fnOrCtrBase, {\n  fields: Object.assign({}, signatureDeclarationCommon(), {\n    abstract: (0, _utils.validateOptional)(bool)\n  })\n}));\ndefineType(\"TSTypeReference\", {\n  aliases: [\"TSType\"],\n  visitor: [\"typeName\", \"typeParameters\"],\n  fields: {\n    typeName: (0, _utils.validateType)(\"TSEntityName\"),\n    typeParameters: (0, _utils.validateOptionalType)(\"TSTypeParameterInstantiation\")\n  }\n});\ndefineType(\"TSTypePredicate\", {\n  aliases: [\"TSType\"],\n  visitor: [\"parameterName\", \"typeAnnotation\"],\n  builder: [\"parameterName\", \"typeAnnotation\", \"asserts\"],\n  fields: {\n    parameterName: (0, _utils.validateType)([\"Identifier\", \"TSThisType\"]),\n    typeAnnotation: (0, _utils.validateOptionalType)(\"TSTypeAnnotation\"),\n    asserts: (0, _utils.validateOptional)(bool)\n  }\n});\ndefineType(\"TSTypeQuery\", {\n  aliases: [\"TSType\"],\n  visitor: [\"exprName\", \"typeParameters\"],\n  fields: {\n    exprName: (0, _utils.validateType)([\"TSEntityName\", \"TSImportType\"]),\n    typeParameters: (0, _utils.validateOptionalType)(\"TSTypeParameterInstantiation\")\n  }\n});\ndefineType(\"TSTypeLiteral\", {\n  aliases: [\"TSType\"],\n  visitor: [\"members\"],\n  fields: {\n    members: (0, _utils.validateArrayOfType)(\"TSTypeElement\")\n  }\n});\ndefineType(\"TSArrayType\", {\n  aliases: [\"TSType\"],\n  visitor: [\"elementType\"],\n  fields: {\n    elementType: (0, _utils.validateType)(\"TSType\")\n  }\n});\ndefineType(\"TSTupleType\", {\n  aliases: [\"TSType\"],\n  visitor: [\"elementTypes\"],\n  fields: {\n    elementTypes: (0, _utils.validateArrayOfType)([\"TSType\", \"TSNamedTupleMember\"])\n  }\n});\ndefineType(\"TSOptionalType\", {\n  aliases: [\"TSType\"],\n  visitor: [\"typeAnnotation\"],\n  fields: {\n    typeAnnotation: (0, _utils.validateType)(\"TSType\")\n  }\n});\ndefineType(\"TSRestType\", {\n  aliases: [\"TSType\"],\n  visitor: [\"typeAnnotation\"],\n  fields: {\n    typeAnnotation: (0, _utils.validateType)(\"TSType\")\n  }\n});\ndefineType(\"TSNamedTupleMember\", {\n  visitor: [\"label\", \"elementType\"],\n  builder: [\"label\", \"elementType\", \"optional\"],\n  fields: {\n    label: (0, _utils.validateType)(\"Identifier\"),\n    optional: {\n      validate: bool,\n      default: false\n    },\n    elementType: (0, _utils.validateType)(\"TSType\")\n  }\n});\nvar unionOrIntersection = {\n  aliases: [\"TSType\"],\n  visitor: [\"types\"],\n  fields: {\n    types: (0, _utils.validateArrayOfType)(\"TSType\")\n  }\n};\ndefineType(\"TSUnionType\", unionOrIntersection);\ndefineType(\"TSIntersectionType\", unionOrIntersection);\ndefineType(\"TSConditionalType\", {\n  aliases: [\"TSType\"],\n  visitor: [\"checkType\", \"extendsType\", \"trueType\", \"falseType\"],\n  fields: {\n    checkType: (0, _utils.validateType)(\"TSType\"),\n    extendsType: (0, _utils.validateType)(\"TSType\"),\n    trueType: (0, _utils.validateType)(\"TSType\"),\n    falseType: (0, _utils.validateType)(\"TSType\")\n  }\n});\ndefineType(\"TSInferType\", {\n  aliases: [\"TSType\"],\n  visitor: [\"typeParameter\"],\n  fields: {\n    typeParameter: (0, _utils.validateType)(\"TSTypeParameter\")\n  }\n});\ndefineType(\"TSParenthesizedType\", {\n  aliases: [\"TSType\"],\n  visitor: [\"typeAnnotation\"],\n  fields: {\n    typeAnnotation: (0, _utils.validateType)(\"TSType\")\n  }\n});\ndefineType(\"TSTypeOperator\", {\n  aliases: [\"TSType\"],\n  visitor: [\"typeAnnotation\"],\n  fields: {\n    operator: (0, _utils.validate)((0, _utils.assertValueType)(\"string\")),\n    typeAnnotation: (0, _utils.validateType)(\"TSType\")\n  }\n});\ndefineType(\"TSIndexedAccessType\", {\n  aliases: [\"TSType\"],\n  visitor: [\"objectType\", \"indexType\"],\n  fields: {\n    objectType: (0, _utils.validateType)(\"TSType\"),\n    indexType: (0, _utils.validateType)(\"TSType\")\n  }\n});\ndefineType(\"TSMappedType\", {\n  aliases: [\"TSType\"],\n  visitor: [\"typeParameter\", \"typeAnnotation\", \"nameType\"],\n  fields: {\n    readonly: (0, _utils.validateOptional)((0, _utils.assertOneOf)(true, false, \"+\", \"-\")),\n    typeParameter: (0, _utils.validateType)(\"TSTypeParameter\"),\n    optional: (0, _utils.validateOptional)((0, _utils.assertOneOf)(true, false, \"+\", \"-\")),\n    typeAnnotation: (0, _utils.validateOptionalType)(\"TSType\"),\n    nameType: (0, _utils.validateOptionalType)(\"TSType\")\n  }\n});\ndefineType(\"TSLiteralType\", {\n  aliases: [\"TSType\", \"TSBaseType\"],\n  visitor: [\"literal\"],\n  fields: {\n    literal: {\n      validate: function () {\n        var unaryExpression = (0, _utils.assertNodeType)(\"NumericLiteral\", \"BigIntLiteral\");\n        var unaryOperator = (0, _utils.assertOneOf)(\"-\");\n        var literal = (0, _utils.assertNodeType)(\"NumericLiteral\", \"StringLiteral\", \"BooleanLiteral\", \"BigIntLiteral\", \"TemplateLiteral\");\n        function validator(parent, key, node) {\n          if ((0, _is.default)(\"UnaryExpression\", node)) {\n            unaryOperator(node, \"operator\", node.operator);\n            unaryExpression(node, \"argument\", node.argument);\n          } else {\n            literal(parent, key, node);\n          }\n        }\n        validator.oneOfNodeTypes = [\"NumericLiteral\", \"StringLiteral\", \"BooleanLiteral\", \"BigIntLiteral\", \"TemplateLiteral\", \"UnaryExpression\"];\n        return validator;\n      }()\n    }\n  }\n});\ndefineType(\"TSExpressionWithTypeArguments\", {\n  aliases: [\"TSType\"],\n  visitor: [\"expression\", \"typeParameters\"],\n  fields: {\n    expression: (0, _utils.validateType)(\"TSEntityName\"),\n    typeParameters: (0, _utils.validateOptionalType)(\"TSTypeParameterInstantiation\")\n  }\n});\ndefineType(\"TSInterfaceDeclaration\", {\n  aliases: [\"Statement\", \"Declaration\"],\n  visitor: [\"id\", \"typeParameters\", \"extends\", \"body\"],\n  fields: {\n    declare: (0, _utils.validateOptional)(bool),\n    id: (0, _utils.validateType)(\"Identifier\"),\n    typeParameters: (0, _utils.validateOptionalType)(\"TSTypeParameterDeclaration\"),\n    extends: (0, _utils.validateOptional)((0, _utils.arrayOfType)(\"TSExpressionWithTypeArguments\")),\n    body: (0, _utils.validateType)(\"TSInterfaceBody\")\n  }\n});\ndefineType(\"TSInterfaceBody\", {\n  visitor: [\"body\"],\n  fields: {\n    body: (0, _utils.validateArrayOfType)(\"TSTypeElement\")\n  }\n});\ndefineType(\"TSTypeAliasDeclaration\", {\n  aliases: [\"Statement\", \"Declaration\"],\n  visitor: [\"id\", \"typeParameters\", \"typeAnnotation\"],\n  fields: {\n    declare: (0, _utils.validateOptional)(bool),\n    id: (0, _utils.validateType)(\"Identifier\"),\n    typeParameters: (0, _utils.validateOptionalType)(\"TSTypeParameterDeclaration\"),\n    typeAnnotation: (0, _utils.validateType)(\"TSType\")\n  }\n});\ndefineType(\"TSInstantiationExpression\", {\n  aliases: [\"Expression\"],\n  visitor: [\"expression\", \"typeParameters\"],\n  fields: {\n    expression: (0, _utils.validateType)(\"Expression\"),\n    typeParameters: (0, _utils.validateOptionalType)(\"TSTypeParameterInstantiation\")\n  }\n});\nvar TSTypeExpression = {\n  aliases: [\"Expression\", \"LVal\", \"PatternLike\"],\n  visitor: [\"expression\", \"typeAnnotation\"],\n  fields: {\n    expression: (0, _utils.validateType)(\"Expression\"),\n    typeAnnotation: (0, _utils.validateType)(\"TSType\")\n  }\n};\ndefineType(\"TSAsExpression\", TSTypeExpression);\ndefineType(\"TSSatisfiesExpression\", TSTypeExpression);\ndefineType(\"TSTypeAssertion\", {\n  aliases: [\"Expression\", \"LVal\", \"PatternLike\"],\n  visitor: [\"typeAnnotation\", \"expression\"],\n  fields: {\n    typeAnnotation: (0, _utils.validateType)(\"TSType\"),\n    expression: (0, _utils.validateType)(\"Expression\")\n  }\n});\ndefineType(\"TSEnumDeclaration\", {\n  aliases: [\"Statement\", \"Declaration\"],\n  visitor: [\"id\", \"members\"],\n  fields: {\n    declare: (0, _utils.validateOptional)(bool),\n    const: (0, _utils.validateOptional)(bool),\n    id: (0, _utils.validateType)(\"Identifier\"),\n    members: (0, _utils.validateArrayOfType)(\"TSEnumMember\"),\n    initializer: (0, _utils.validateOptionalType)(\"Expression\")\n  }\n});\ndefineType(\"TSEnumMember\", {\n  visitor: [\"id\", \"initializer\"],\n  fields: {\n    id: (0, _utils.validateType)([\"Identifier\", \"StringLiteral\"]),\n    initializer: (0, _utils.validateOptionalType)(\"Expression\")\n  }\n});\ndefineType(\"TSModuleDeclaration\", {\n  aliases: [\"Statement\", \"Declaration\"],\n  visitor: [\"id\", \"body\"],\n  fields: {\n    declare: (0, _utils.validateOptional)(bool),\n    global: (0, _utils.validateOptional)(bool),\n    id: (0, _utils.validateType)([\"Identifier\", \"StringLiteral\"]),\n    body: (0, _utils.validateType)([\"TSModuleBlock\", \"TSModuleDeclaration\"])\n  }\n});\ndefineType(\"TSModuleBlock\", {\n  aliases: [\"Scopable\", \"Block\", \"BlockParent\", \"FunctionParent\"],\n  visitor: [\"body\"],\n  fields: {\n    body: (0, _utils.validateArrayOfType)(\"Statement\")\n  }\n});\ndefineType(\"TSImportType\", {\n  aliases: [\"TSType\"],\n  visitor: [\"argument\", \"qualifier\", \"typeParameters\"],\n  fields: {\n    argument: (0, _utils.validateType)(\"StringLiteral\"),\n    qualifier: (0, _utils.validateOptionalType)(\"TSEntityName\"),\n    typeParameters: (0, _utils.validateOptionalType)(\"TSTypeParameterInstantiation\")\n  }\n});\ndefineType(\"TSImportEqualsDeclaration\", {\n  aliases: [\"Statement\"],\n  visitor: [\"id\", \"moduleReference\"],\n  fields: {\n    isExport: (0, _utils.validate)(bool),\n    id: (0, _utils.validateType)(\"Identifier\"),\n    moduleReference: (0, _utils.validateType)([\"TSEntityName\", \"TSExternalModuleReference\"]),\n    importKind: {\n      validate: (0, _utils.assertOneOf)(\"type\", \"value\"),\n      optional: true\n    }\n  }\n});\ndefineType(\"TSExternalModuleReference\", {\n  visitor: [\"expression\"],\n  fields: {\n    expression: (0, _utils.validateType)(\"StringLiteral\")\n  }\n});\ndefineType(\"TSNonNullExpression\", {\n  aliases: [\"Expression\", \"LVal\", \"PatternLike\"],\n  visitor: [\"expression\"],\n  fields: {\n    expression: (0, _utils.validateType)(\"Expression\")\n  }\n});\ndefineType(\"TSExportAssignment\", {\n  aliases: [\"Statement\"],\n  visitor: [\"expression\"],\n  fields: {\n    expression: (0, _utils.validateType)(\"Expression\")\n  }\n});\ndefineType(\"TSNamespaceExportDeclaration\", {\n  aliases: [\"Statement\"],\n  visitor: [\"id\"],\n  fields: {\n    id: (0, _utils.validateType)(\"Identifier\")\n  }\n});\ndefineType(\"TSTypeAnnotation\", {\n  visitor: [\"typeAnnotation\"],\n  fields: {\n    typeAnnotation: {\n      validate: (0, _utils.assertNodeType)(\"TSType\")\n    }\n  }\n});\ndefineType(\"TSTypeParameterInstantiation\", {\n  visitor: [\"params\"],\n  fields: {\n    params: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"TSType\")))\n    }\n  }\n});\ndefineType(\"TSTypeParameterDeclaration\", {\n  visitor: [\"params\"],\n  fields: {\n    params: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"TSTypeParameter\")))\n    }\n  }\n});\ndefineType(\"TSTypeParameter\", {\n  builder: [\"constraint\", \"default\", \"name\"],\n  visitor: [\"constraint\", \"default\"],\n  fields: {\n    name: {\n      validate: (0, _utils.assertValueType)(\"string\")\n    },\n    in: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    out: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    const: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    constraint: {\n      validate: (0, _utils.assertNodeType)(\"TSType\"),\n      optional: true\n    },\n    default: {\n      validate: (0, _utils.assertNodeType)(\"TSType\"),\n      optional: true\n    }\n  }\n});","map":{"version":3,"names":["_utils","require","_core","_is","defineType","defineAliasedType","bool","assertValueType","tSFunctionTypeAnnotationCommon","returnType","validate","assertNodeType","optional","typeParameters","aliases","visitor","fields","accessibility","assertOneOf","readonly","parameter","override","decorators","chain","assertEach","Object","assign","functionDeclarationCommon","classMethodOrDeclareMethodCommon","left","validateType","right","signatureDeclarationCommon","_ref","validateOptionalType","_defineProperty","validateArrayOfType","callConstructSignatureDeclaration","namedTypeElementCommon","key","computed","default","validateOptional","typeAnnotation","initializer","kind","static","parameters","tsKeywordTypes","_i","_tsKeywordTypes","length","type","fnOrCtrBase","abstract","typeName","builder","parameterName","asserts","exprName","members","elementType","elementTypes","label","unionOrIntersection","types","checkType","extendsType","trueType","falseType","typeParameter","operator","objectType","indexType","nameType","literal","unaryExpression","unaryOperator","validator","parent","node","argument","oneOfNodeTypes","expression","declare","id","extends","arrayOfType","body","TSTypeExpression","const","global","qualifier","isExport","moduleReference","importKind","params","name","in","out","constraint"],"sources":["C:\\Users\\pongster\\Documents\\ezpcbutworkingthistime\\FRONTEND\\node_modules\\@babel\\types\\src\\definitions\\typescript.ts"],"sourcesContent":["import {\n  defineAliasedType,\n  arrayOfType,\n  assertEach,\n  assertNodeType,\n  assertOneOf,\n  assertValueType,\n  chain,\n  validate,\n  validateArrayOfType,\n  validateOptional,\n  validateOptionalType,\n  validateType,\n} from \"./utils\";\nimport {\n  functionDeclarationCommon,\n  classMethodOrDeclareMethodCommon,\n} from \"./core\";\nimport is from \"../validators/is\";\n\nconst defineType = defineAliasedType(\"TypeScript\");\n\nconst bool = assertValueType(\"boolean\");\n\nconst tSFunctionTypeAnnotationCommon = () => ({\n  returnType: {\n    validate: process.env.BABEL_8_BREAKING\n      ? assertNodeType(\"TSTypeAnnotation\")\n      : // @ts-ignore(Babel 7 vs Babel 8) Babel 7 AST\n        assertNodeType(\"TSTypeAnnotation\", \"Noop\"),\n    optional: true,\n  },\n  typeParameters: {\n    validate: process.env.BABEL_8_BREAKING\n      ? assertNodeType(\"TSTypeParameterDeclaration\")\n      : // @ts-ignore(Babel 7 vs Babel 8) Babel 7 AST\n        assertNodeType(\"TSTypeParameterDeclaration\", \"Noop\"),\n    optional: true,\n  },\n});\n\ndefineType(\"TSParameterProperty\", {\n  aliases: [\"LVal\"], // TODO: This isn't usable in general as an LVal. Should have a \"Parameter\" alias.\n  visitor: [\"parameter\"],\n  fields: {\n    accessibility: {\n      validate: assertOneOf(\"public\", \"private\", \"protected\"),\n      optional: true,\n    },\n    readonly: {\n      validate: assertValueType(\"boolean\"),\n      optional: true,\n    },\n    parameter: {\n      validate: assertNodeType(\"Identifier\", \"AssignmentPattern\"),\n    },\n    override: {\n      validate: assertValueType(\"boolean\"),\n      optional: true,\n    },\n    decorators: {\n      validate: chain(\n        assertValueType(\"array\"),\n        assertEach(assertNodeType(\"Decorator\")),\n      ),\n      optional: true,\n    },\n  },\n});\n\ndefineType(\"TSDeclareFunction\", {\n  aliases: [\"Statement\", \"Declaration\"],\n  visitor: [\"id\", \"typeParameters\", \"params\", \"returnType\"],\n  fields: {\n    ...functionDeclarationCommon(),\n    ...tSFunctionTypeAnnotationCommon(),\n  },\n});\n\ndefineType(\"TSDeclareMethod\", {\n  visitor: [\"decorators\", \"key\", \"typeParameters\", \"params\", \"returnType\"],\n  fields: {\n    ...classMethodOrDeclareMethodCommon(),\n    ...tSFunctionTypeAnnotationCommon(),\n  },\n});\n\ndefineType(\"TSQualifiedName\", {\n  aliases: [\"TSEntityName\"],\n  visitor: [\"left\", \"right\"],\n  fields: {\n    left: validateType(\"TSEntityName\"),\n    right: validateType(\"Identifier\"),\n  },\n});\n\nconst signatureDeclarationCommon = () => ({\n  typeParameters: validateOptionalType(\"TSTypeParameterDeclaration\"),\n  [process.env.BABEL_8_BREAKING ? \"params\" : \"parameters\"]: validateArrayOfType(\n    [\"Identifier\", \"RestElement\"],\n  ),\n  [process.env.BABEL_8_BREAKING ? \"returnType\" : \"typeAnnotation\"]:\n    validateOptionalType(\"TSTypeAnnotation\"),\n});\n\nconst callConstructSignatureDeclaration = {\n  aliases: [\"TSTypeElement\"],\n  visitor: [\n    \"typeParameters\",\n    process.env.BABEL_8_BREAKING ? \"params\" : \"parameters\",\n    process.env.BABEL_8_BREAKING ? \"returnType\" : \"typeAnnotation\",\n  ],\n  fields: signatureDeclarationCommon(),\n};\n\ndefineType(\"TSCallSignatureDeclaration\", callConstructSignatureDeclaration);\ndefineType(\n  \"TSConstructSignatureDeclaration\",\n  callConstructSignatureDeclaration,\n);\n\nconst namedTypeElementCommon = () => ({\n  key: validateType(\"Expression\"),\n  computed: { default: false },\n  optional: validateOptional(bool),\n});\n\ndefineType(\"TSPropertySignature\", {\n  aliases: [\"TSTypeElement\"],\n  visitor: [\"key\", \"typeAnnotation\", \"initializer\"],\n  fields: {\n    ...namedTypeElementCommon(),\n    readonly: validateOptional(bool),\n    typeAnnotation: validateOptionalType(\"TSTypeAnnotation\"),\n    initializer: validateOptionalType(\"Expression\"),\n    kind: {\n      validate: assertOneOf(\"get\", \"set\"),\n    },\n  },\n});\n\ndefineType(\"TSMethodSignature\", {\n  aliases: [\"TSTypeElement\"],\n  visitor: [\n    \"key\",\n    \"typeParameters\",\n    process.env.BABEL_8_BREAKING ? \"params\" : \"parameters\",\n    process.env.BABEL_8_BREAKING ? \"returnType\" : \"typeAnnotation\",\n  ],\n  fields: {\n    ...signatureDeclarationCommon(),\n    ...namedTypeElementCommon(),\n    kind: {\n      validate: assertOneOf(\"method\", \"get\", \"set\"),\n    },\n  },\n});\n\ndefineType(\"TSIndexSignature\", {\n  aliases: [\"TSTypeElement\"],\n  visitor: [\"parameters\", \"typeAnnotation\"],\n  fields: {\n    readonly: validateOptional(bool),\n    static: validateOptional(bool),\n    parameters: validateArrayOfType(\"Identifier\"), // Length must be 1\n    typeAnnotation: validateOptionalType(\"TSTypeAnnotation\"),\n  },\n});\n\nconst tsKeywordTypes = [\n  \"TSAnyKeyword\",\n  \"TSBooleanKeyword\",\n  \"TSBigIntKeyword\",\n  \"TSIntrinsicKeyword\",\n  \"TSNeverKeyword\",\n  \"TSNullKeyword\",\n  \"TSNumberKeyword\",\n  \"TSObjectKeyword\",\n  \"TSStringKeyword\",\n  \"TSSymbolKeyword\",\n  \"TSUndefinedKeyword\",\n  \"TSUnknownKeyword\",\n  \"TSVoidKeyword\",\n] as const;\n\nfor (const type of tsKeywordTypes) {\n  defineType(type, {\n    aliases: [\"TSType\", \"TSBaseType\"],\n    visitor: [],\n    fields: {},\n  });\n}\n\ndefineType(\"TSThisType\", {\n  aliases: [\"TSType\", \"TSBaseType\"],\n  visitor: [],\n  fields: {},\n});\n\nconst fnOrCtrBase = {\n  aliases: [\"TSType\"],\n  visitor: [\n    \"typeParameters\",\n    process.env.BABEL_8_BREAKING ? \"params\" : \"parameters\",\n    process.env.BABEL_8_BREAKING ? \"returnType\" : \"typeAnnotation\",\n  ],\n};\n\ndefineType(\"TSFunctionType\", {\n  ...fnOrCtrBase,\n  fields: signatureDeclarationCommon(),\n});\ndefineType(\"TSConstructorType\", {\n  ...fnOrCtrBase,\n  fields: {\n    ...signatureDeclarationCommon(),\n    abstract: validateOptional(bool),\n  },\n});\n\ndefineType(\"TSTypeReference\", {\n  aliases: [\"TSType\"],\n  visitor: [\"typeName\", \"typeParameters\"],\n  fields: {\n    typeName: validateType(\"TSEntityName\"),\n    typeParameters: validateOptionalType(\"TSTypeParameterInstantiation\"),\n  },\n});\n\ndefineType(\"TSTypePredicate\", {\n  aliases: [\"TSType\"],\n  visitor: [\"parameterName\", \"typeAnnotation\"],\n  builder: [\"parameterName\", \"typeAnnotation\", \"asserts\"],\n  fields: {\n    parameterName: validateType([\"Identifier\", \"TSThisType\"]),\n    typeAnnotation: validateOptionalType(\"TSTypeAnnotation\"),\n    asserts: validateOptional(bool),\n  },\n});\n\ndefineType(\"TSTypeQuery\", {\n  aliases: [\"TSType\"],\n  visitor: [\"exprName\", \"typeParameters\"],\n  fields: {\n    exprName: validateType([\"TSEntityName\", \"TSImportType\"]),\n    typeParameters: validateOptionalType(\"TSTypeParameterInstantiation\"),\n  },\n});\n\ndefineType(\"TSTypeLiteral\", {\n  aliases: [\"TSType\"],\n  visitor: [\"members\"],\n  fields: {\n    members: validateArrayOfType(\"TSTypeElement\"),\n  },\n});\n\ndefineType(\"TSArrayType\", {\n  aliases: [\"TSType\"],\n  visitor: [\"elementType\"],\n  fields: {\n    elementType: validateType(\"TSType\"),\n  },\n});\n\ndefineType(\"TSTupleType\", {\n  aliases: [\"TSType\"],\n  visitor: [\"elementTypes\"],\n  fields: {\n    elementTypes: validateArrayOfType([\"TSType\", \"TSNamedTupleMember\"]),\n  },\n});\n\ndefineType(\"TSOptionalType\", {\n  aliases: [\"TSType\"],\n  visitor: [\"typeAnnotation\"],\n  fields: {\n    typeAnnotation: validateType(\"TSType\"),\n  },\n});\n\ndefineType(\"TSRestType\", {\n  aliases: [\"TSType\"],\n  visitor: [\"typeAnnotation\"],\n  fields: {\n    typeAnnotation: validateType(\"TSType\"),\n  },\n});\n\ndefineType(\"TSNamedTupleMember\", {\n  visitor: [\"label\", \"elementType\"],\n  builder: [\"label\", \"elementType\", \"optional\"],\n  fields: {\n    label: validateType(\"Identifier\"),\n    optional: {\n      validate: bool,\n      default: false,\n    },\n    elementType: validateType(\"TSType\"),\n  },\n});\n\nconst unionOrIntersection = {\n  aliases: [\"TSType\"],\n  visitor: [\"types\"],\n  fields: {\n    types: validateArrayOfType(\"TSType\"),\n  },\n};\n\ndefineType(\"TSUnionType\", unionOrIntersection);\ndefineType(\"TSIntersectionType\", unionOrIntersection);\n\ndefineType(\"TSConditionalType\", {\n  aliases: [\"TSType\"],\n  visitor: [\"checkType\", \"extendsType\", \"trueType\", \"falseType\"],\n  fields: {\n    checkType: validateType(\"TSType\"),\n    extendsType: validateType(\"TSType\"),\n    trueType: validateType(\"TSType\"),\n    falseType: validateType(\"TSType\"),\n  },\n});\n\ndefineType(\"TSInferType\", {\n  aliases: [\"TSType\"],\n  visitor: [\"typeParameter\"],\n  fields: {\n    typeParameter: validateType(\"TSTypeParameter\"),\n  },\n});\n\ndefineType(\"TSParenthesizedType\", {\n  aliases: [\"TSType\"],\n  visitor: [\"typeAnnotation\"],\n  fields: {\n    typeAnnotation: validateType(\"TSType\"),\n  },\n});\n\ndefineType(\"TSTypeOperator\", {\n  aliases: [\"TSType\"],\n  visitor: [\"typeAnnotation\"],\n  fields: {\n    operator: validate(assertValueType(\"string\")),\n    typeAnnotation: validateType(\"TSType\"),\n  },\n});\n\ndefineType(\"TSIndexedAccessType\", {\n  aliases: [\"TSType\"],\n  visitor: [\"objectType\", \"indexType\"],\n  fields: {\n    objectType: validateType(\"TSType\"),\n    indexType: validateType(\"TSType\"),\n  },\n});\n\ndefineType(\"TSMappedType\", {\n  aliases: [\"TSType\"],\n  visitor: [\"typeParameter\", \"typeAnnotation\", \"nameType\"],\n  fields: {\n    readonly: validateOptional(assertOneOf(true, false, \"+\", \"-\")),\n    typeParameter: validateType(\"TSTypeParameter\"),\n    optional: validateOptional(assertOneOf(true, false, \"+\", \"-\")),\n    typeAnnotation: validateOptionalType(\"TSType\"),\n    nameType: validateOptionalType(\"TSType\"),\n  },\n});\n\ndefineType(\"TSLiteralType\", {\n  aliases: [\"TSType\", \"TSBaseType\"],\n  visitor: [\"literal\"],\n  fields: {\n    literal: {\n      validate: (function () {\n        const unaryExpression = assertNodeType(\n          \"NumericLiteral\",\n          \"BigIntLiteral\",\n        );\n        const unaryOperator = assertOneOf(\"-\");\n\n        const literal = assertNodeType(\n          \"NumericLiteral\",\n          \"StringLiteral\",\n          \"BooleanLiteral\",\n          \"BigIntLiteral\",\n          \"TemplateLiteral\",\n        );\n        function validator(parent: any, key: string, node: any) {\n          // type A = -1 | 1;\n          if (is(\"UnaryExpression\", node)) {\n            // check operator first\n            unaryOperator(node, \"operator\", node.operator);\n            unaryExpression(node, \"argument\", node.argument);\n          } else {\n            // type A = 'foo' | 'bar' | false | 1;\n            literal(parent, key, node);\n          }\n        }\n\n        validator.oneOfNodeTypes = [\n          \"NumericLiteral\",\n          \"StringLiteral\",\n          \"BooleanLiteral\",\n          \"BigIntLiteral\",\n          \"TemplateLiteral\",\n          \"UnaryExpression\",\n        ];\n\n        return validator;\n      })(),\n    },\n  },\n});\n\ndefineType(\"TSExpressionWithTypeArguments\", {\n  aliases: [\"TSType\"],\n  visitor: [\"expression\", \"typeParameters\"],\n  fields: {\n    expression: validateType(\"TSEntityName\"),\n    typeParameters: validateOptionalType(\"TSTypeParameterInstantiation\"),\n  },\n});\n\ndefineType(\"TSInterfaceDeclaration\", {\n  // \"Statement\" alias prevents a semicolon from appearing after it in an export declaration.\n  aliases: [\"Statement\", \"Declaration\"],\n  visitor: [\"id\", \"typeParameters\", \"extends\", \"body\"],\n  fields: {\n    declare: validateOptional(bool),\n    id: validateType(\"Identifier\"),\n    typeParameters: validateOptionalType(\"TSTypeParameterDeclaration\"),\n    extends: validateOptional(arrayOfType(\"TSExpressionWithTypeArguments\")),\n    body: validateType(\"TSInterfaceBody\"),\n  },\n});\n\ndefineType(\"TSInterfaceBody\", {\n  visitor: [\"body\"],\n  fields: {\n    body: validateArrayOfType(\"TSTypeElement\"),\n  },\n});\n\ndefineType(\"TSTypeAliasDeclaration\", {\n  aliases: [\"Statement\", \"Declaration\"],\n  visitor: [\"id\", \"typeParameters\", \"typeAnnotation\"],\n  fields: {\n    declare: validateOptional(bool),\n    id: validateType(\"Identifier\"),\n    typeParameters: validateOptionalType(\"TSTypeParameterDeclaration\"),\n    typeAnnotation: validateType(\"TSType\"),\n  },\n});\n\ndefineType(\"TSInstantiationExpression\", {\n  aliases: [\"Expression\"],\n  visitor: [\"expression\", \"typeParameters\"],\n  fields: {\n    expression: validateType(\"Expression\"),\n    typeParameters: validateOptionalType(\"TSTypeParameterInstantiation\"),\n  },\n});\n\nconst TSTypeExpression = {\n  aliases: [\"Expression\", \"LVal\", \"PatternLike\"],\n  visitor: [\"expression\", \"typeAnnotation\"],\n  fields: {\n    expression: validateType(\"Expression\"),\n    typeAnnotation: validateType(\"TSType\"),\n  },\n};\n\ndefineType(\"TSAsExpression\", TSTypeExpression);\ndefineType(\"TSSatisfiesExpression\", TSTypeExpression);\n\ndefineType(\"TSTypeAssertion\", {\n  aliases: [\"Expression\", \"LVal\", \"PatternLike\"],\n  visitor: [\"typeAnnotation\", \"expression\"],\n  fields: {\n    typeAnnotation: validateType(\"TSType\"),\n    expression: validateType(\"Expression\"),\n  },\n});\n\ndefineType(\"TSEnumDeclaration\", {\n  // \"Statement\" alias prevents a semicolon from appearing after it in an export declaration.\n  aliases: [\"Statement\", \"Declaration\"],\n  visitor: [\"id\", \"members\"],\n  fields: {\n    declare: validateOptional(bool),\n    const: validateOptional(bool),\n    id: validateType(\"Identifier\"),\n    members: validateArrayOfType(\"TSEnumMember\"),\n    initializer: validateOptionalType(\"Expression\"),\n  },\n});\n\ndefineType(\"TSEnumMember\", {\n  visitor: [\"id\", \"initializer\"],\n  fields: {\n    id: validateType([\"Identifier\", \"StringLiteral\"]),\n    initializer: validateOptionalType(\"Expression\"),\n  },\n});\n\ndefineType(\"TSModuleDeclaration\", {\n  aliases: [\"Statement\", \"Declaration\"],\n  visitor: [\"id\", \"body\"],\n  fields: {\n    declare: validateOptional(bool),\n    global: validateOptional(bool),\n    id: validateType([\"Identifier\", \"StringLiteral\"]),\n    body: validateType([\"TSModuleBlock\", \"TSModuleDeclaration\"]),\n  },\n});\n\ndefineType(\"TSModuleBlock\", {\n  aliases: [\"Scopable\", \"Block\", \"BlockParent\", \"FunctionParent\"],\n  visitor: [\"body\"],\n  fields: {\n    body: validateArrayOfType(\"Statement\"),\n  },\n});\n\ndefineType(\"TSImportType\", {\n  aliases: [\"TSType\"],\n  visitor: [\"argument\", \"qualifier\", \"typeParameters\"],\n  fields: {\n    argument: validateType(\"StringLiteral\"),\n    qualifier: validateOptionalType(\"TSEntityName\"),\n    typeParameters: validateOptionalType(\"TSTypeParameterInstantiation\"),\n  },\n});\n\ndefineType(\"TSImportEqualsDeclaration\", {\n  aliases: [\"Statement\"],\n  visitor: [\"id\", \"moduleReference\"],\n  fields: {\n    isExport: validate(bool),\n    id: validateType(\"Identifier\"),\n    moduleReference: validateType([\n      \"TSEntityName\",\n      \"TSExternalModuleReference\",\n    ]),\n    importKind: {\n      validate: assertOneOf(\"type\", \"value\"),\n      optional: true,\n    },\n  },\n});\n\ndefineType(\"TSExternalModuleReference\", {\n  visitor: [\"expression\"],\n  fields: {\n    expression: validateType(\"StringLiteral\"),\n  },\n});\n\ndefineType(\"TSNonNullExpression\", {\n  aliases: [\"Expression\", \"LVal\", \"PatternLike\"],\n  visitor: [\"expression\"],\n  fields: {\n    expression: validateType(\"Expression\"),\n  },\n});\n\ndefineType(\"TSExportAssignment\", {\n  aliases: [\"Statement\"],\n  visitor: [\"expression\"],\n  fields: {\n    expression: validateType(\"Expression\"),\n  },\n});\n\ndefineType(\"TSNamespaceExportDeclaration\", {\n  aliases: [\"Statement\"],\n  visitor: [\"id\"],\n  fields: {\n    id: validateType(\"Identifier\"),\n  },\n});\n\ndefineType(\"TSTypeAnnotation\", {\n  visitor: [\"typeAnnotation\"],\n  fields: {\n    typeAnnotation: {\n      validate: assertNodeType(\"TSType\"),\n    },\n  },\n});\n\ndefineType(\"TSTypeParameterInstantiation\", {\n  visitor: [\"params\"],\n  fields: {\n    params: {\n      validate: chain(\n        assertValueType(\"array\"),\n        assertEach(assertNodeType(\"TSType\")),\n      ),\n    },\n  },\n});\n\ndefineType(\"TSTypeParameterDeclaration\", {\n  visitor: [\"params\"],\n  fields: {\n    params: {\n      validate: chain(\n        assertValueType(\"array\"),\n        assertEach(assertNodeType(\"TSTypeParameter\")),\n      ),\n    },\n  },\n});\n\ndefineType(\"TSTypeParameter\", {\n  builder: [\"constraint\", \"default\", \"name\"],\n  visitor: [\"constraint\", \"default\"],\n  fields: {\n    name: {\n      validate: !process.env.BABEL_8_BREAKING\n        ? assertValueType(\"string\")\n        : assertNodeType(\"Identifier\"),\n    },\n    in: {\n      validate: assertValueType(\"boolean\"),\n      optional: true,\n    },\n    out: {\n      validate: assertValueType(\"boolean\"),\n      optional: true,\n    },\n    const: {\n      validate: assertValueType(\"boolean\"),\n      optional: true,\n    },\n    constraint: {\n      validate: assertNodeType(\"TSType\"),\n      optional: true,\n    },\n    default: {\n      validate: assertNodeType(\"TSType\"),\n      optional: true,\n    },\n  },\n});\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}