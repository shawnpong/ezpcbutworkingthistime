{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"C:/Users/pongster/Documents/ezpcbutworkingthistime/FRONTEND/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\nvar _createForOfIteratorHelper = require(\"C:/Users/pongster/Documents/ezpcbutworkingthistime/FRONTEND/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _toConsumableArray = require(\"C:/Users/pongster/Documents/ezpcbutworkingthistime/FRONTEND/node_modules/@babel/runtime/helpers/toConsumableArray.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = removeTypeDuplicates;\nvar _generated = require(\"../../validators/generated\");\nfunction getQualifiedName(node) {\n  return (0, _generated.isIdentifier)(node) ? node.name : \"\".concat(node.right.name, \".\").concat(getQualifiedName(node.left));\n}\nfunction removeTypeDuplicates(nodesIn) {\n  var nodes = Array.from(nodesIn);\n  var generics = new Map();\n  var bases = new Map();\n  var typeGroups = new Set();\n  var types = [];\n  for (var i = 0; i < nodes.length; i++) {\n    var node = nodes[i];\n    if (!node) continue;\n    if (types.indexOf(node) >= 0) {\n      continue;\n    }\n    if ((0, _generated.isTSAnyKeyword)(node)) {\n      return [node];\n    }\n    if ((0, _generated.isTSBaseType)(node)) {\n      bases.set(node.type, node);\n      continue;\n    }\n    if ((0, _generated.isTSUnionType)(node)) {\n      if (!typeGroups.has(node.types)) {\n        nodes.push.apply(nodes, _toConsumableArray(node.types));\n        typeGroups.add(node.types);\n      }\n      continue;\n    }\n    if ((0, _generated.isTSTypeReference)(node) && node.typeParameters) {\n      var name = getQualifiedName(node.typeName);\n      if (generics.has(name)) {\n        var existing = generics.get(name);\n        if (existing.typeParameters) {\n          if (node.typeParameters) {\n            var _existing$typeParamet;\n            (_existing$typeParamet = existing.typeParameters.params).push.apply(_existing$typeParamet, _toConsumableArray(node.typeParameters.params));\n            existing.typeParameters.params = removeTypeDuplicates(existing.typeParameters.params);\n          }\n        } else {\n          existing = node.typeParameters;\n        }\n      } else {\n        generics.set(name, node);\n      }\n      continue;\n    }\n    types.push(node);\n  }\n  var _iterator = _createForOfIteratorHelper(bases),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var _step$value = _slicedToArray(_step.value, 2),\n        baseType = _step$value[1];\n      types.push(baseType);\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  var _iterator2 = _createForOfIteratorHelper(generics),\n    _step2;\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var _step2$value = _slicedToArray(_step2.value, 2),\n        genericName = _step2$value[1];\n      types.push(genericName);\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n  return types;\n}","map":{"version":3,"names":["_generated","require","getQualifiedName","node","isIdentifier","name","concat","right","left","removeTypeDuplicates","nodesIn","nodes","Array","from","generics","Map","bases","typeGroups","Set","types","i","length","indexOf","isTSAnyKeyword","isTSBaseType","set","type","isTSUnionType","has","push","apply","_toConsumableArray","add","isTSTypeReference","typeParameters","typeName","existing","get","_existing$typeParamet","params","_iterator","_createForOfIteratorHelper","_step","s","n","done","_step$value","_slicedToArray","value","baseType","err","e","f","_iterator2","_step2","_step2$value","genericName"],"sources":["C:\\Users\\pongster\\Documents\\ezpcbutworkingthistime\\FRONTEND\\node_modules\\@babel\\types\\src\\modifications\\typescript\\removeTypeDuplicates.ts"],"sourcesContent":["import {\n  isIdentifier,\n  isTSAnyKeyword,\n  isTSTypeReference,\n  isTSUnionType,\n  isTSBaseType,\n} from \"../../validators/generated\";\nimport type * as t from \"../..\";\n\nfunction getQualifiedName(node: t.TSTypeReference[\"typeName\"]): string {\n  return isIdentifier(node)\n    ? node.name\n    : `${node.right.name}.${getQualifiedName(node.left)}`;\n}\n\n/**\n * Dedupe type annotations.\n */\nexport default function removeTypeDuplicates(\n  nodesIn: ReadonlyArray<t.TSType>,\n): Array<t.TSType> {\n  const nodes = Array.from(nodesIn);\n\n  const generics = new Map<string, t.TSTypeReference>();\n  const bases = new Map<t.TSBaseType[\"type\"], t.TSBaseType>();\n\n  // store union type groups to circular references\n  const typeGroups = new Set<t.TSType[]>();\n\n  const types: t.TSType[] = [];\n\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    if (!node) continue;\n\n    // detect duplicates\n    if (types.indexOf(node) >= 0) {\n      continue;\n    }\n\n    // this type matches anything\n    if (isTSAnyKeyword(node)) {\n      return [node];\n    }\n\n    // Analogue of FlowBaseAnnotation\n    if (isTSBaseType(node)) {\n      bases.set(node.type, node);\n      continue;\n    }\n\n    if (isTSUnionType(node)) {\n      if (!typeGroups.has(node.types)) {\n        nodes.push(...node.types);\n        typeGroups.add(node.types);\n      }\n      continue;\n    }\n\n    // todo: support merging tuples: number[]\n    if (isTSTypeReference(node) && node.typeParameters) {\n      const name = getQualifiedName(node.typeName);\n\n      if (generics.has(name)) {\n        let existing: t.TypeScript = generics.get(name);\n        if (existing.typeParameters) {\n          if (node.typeParameters) {\n            existing.typeParameters.params.push(...node.typeParameters.params);\n            existing.typeParameters.params = removeTypeDuplicates(\n              existing.typeParameters.params,\n            );\n          }\n        } else {\n          existing = node.typeParameters;\n        }\n      } else {\n        generics.set(name, node);\n      }\n\n      continue;\n    }\n\n    types.push(node);\n  }\n\n  // add back in bases\n  for (const [, baseType] of bases) {\n    types.push(baseType);\n  }\n\n  // add back in generics\n  for (const [, genericName] of generics) {\n    types.push(genericName);\n  }\n\n  return types;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}