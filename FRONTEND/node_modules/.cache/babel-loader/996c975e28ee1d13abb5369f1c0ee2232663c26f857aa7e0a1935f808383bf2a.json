{"ast":null,"code":"\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"C:/Users/pongster/Documents/ezpcbutworkingthistime/FRONTEND/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = traverse;\nvar _definitions = require(\"../definitions\");\nfunction traverse(node, handlers, state) {\n  if (typeof handlers === \"function\") {\n    handlers = {\n      enter: handlers\n    };\n  }\n  var _handlers = handlers,\n    enter = _handlers.enter,\n    exit = _handlers.exit;\n  traverseSimpleImpl(node, enter, exit, state, []);\n}\nfunction traverseSimpleImpl(node, enter, exit, state, ancestors) {\n  var keys = _definitions.VISITOR_KEYS[node.type];\n  if (!keys) return;\n  if (enter) enter(node, ancestors, state);\n  var _iterator = _createForOfIteratorHelper(keys),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var key = _step.value;\n      var subNode = node[key];\n      if (Array.isArray(subNode)) {\n        for (var i = 0; i < subNode.length; i++) {\n          var child = subNode[i];\n          if (!child) continue;\n          ancestors.push({\n            node: node,\n            key: key,\n            index: i\n          });\n          traverseSimpleImpl(child, enter, exit, state, ancestors);\n          ancestors.pop();\n        }\n      } else if (subNode) {\n        ancestors.push({\n          node: node,\n          key: key\n        });\n        traverseSimpleImpl(subNode, enter, exit, state, ancestors);\n        ancestors.pop();\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  if (exit) exit(node, ancestors, state);\n}","map":{"version":3,"names":["_definitions","require","traverse","node","handlers","state","enter","_handlers","exit","traverseSimpleImpl","ancestors","keys","VISITOR_KEYS","type","_iterator","_createForOfIteratorHelper","_step","s","n","done","key","value","subNode","Array","isArray","i","length","child","push","index","pop","err","e","f"],"sources":["C:\\Users\\pongster\\Documents\\ezpcbutworkingthistime\\FRONTEND\\node_modules\\@babel\\types\\src\\traverse\\traverse.ts"],"sourcesContent":["import { VISITOR_KEYS } from \"../definitions\";\nimport type * as t from \"..\";\n\nexport type TraversalAncestors = Array<{\n  node: t.Node;\n  key: string;\n  index?: number;\n}>;\n\nexport type TraversalHandler<T> = (\n  this: undefined,\n  node: t.Node,\n  parent: TraversalAncestors,\n  state: T,\n) => void;\n\nexport type TraversalHandlers<T> = {\n  enter?: TraversalHandler<T>;\n  exit?: TraversalHandler<T>;\n};\n\n/**\n * A general AST traversal with both prefix and postfix handlers, and a\n * state object. Exposes ancestry data to each handler so that more complex\n * AST data can be taken into account.\n */\nexport default function traverse<T>(\n  node: t.Node,\n  handlers: TraversalHandler<T> | TraversalHandlers<T>,\n  state?: T,\n): void {\n  if (typeof handlers === \"function\") {\n    handlers = { enter: handlers };\n  }\n\n  const { enter, exit } = handlers;\n\n  traverseSimpleImpl(node, enter, exit, state, []);\n}\n\nfunction traverseSimpleImpl<T>(\n  node: any,\n  enter: Function | undefined,\n  exit: Function | undefined,\n  state: T | undefined,\n  ancestors: TraversalAncestors,\n) {\n  const keys = VISITOR_KEYS[node.type];\n  if (!keys) return;\n\n  if (enter) enter(node, ancestors, state);\n\n  for (const key of keys) {\n    const subNode = node[key];\n\n    if (Array.isArray(subNode)) {\n      for (let i = 0; i < subNode.length; i++) {\n        const child = subNode[i];\n        if (!child) continue;\n\n        ancestors.push({\n          node,\n          key,\n          index: i,\n        });\n\n        traverseSimpleImpl(child, enter, exit, state, ancestors);\n\n        ancestors.pop();\n      }\n    } else if (subNode) {\n      ancestors.push({\n        node,\n        key,\n      });\n\n      traverseSimpleImpl(subNode, enter, exit, state, ancestors);\n\n      ancestors.pop();\n    }\n  }\n\n  if (exit) exit(node, ancestors, state);\n}\n"],"mappings":";;;;;;;AAAA,IAAAA,YAAA,GAAAC,OAAA;AA0Be,SAASC,QAAQA,CAC9BC,IAAY,EACZC,QAAoD,EACpDC,KAAS,EACH;EACN,IAAI,OAAOD,QAAQ,KAAK,UAAU,EAAE;IAClCA,QAAQ,GAAG;MAAEE,KAAK,EAAEF;IAAS,CAAC;EAChC;EAEA,IAAAG,SAAA,GAAwBH,QAAQ;IAAxBE,KAAK,GAAAC,SAAA,CAALD,KAAK;IAAEE,IAAA,GAAAD,SAAA,CAAAC,IAAA;EAEfC,kBAAkB,CAACN,IAAI,EAAEG,KAAK,EAAEE,IAAI,EAAEH,KAAK,EAAE,EAAE,CAAC;AAClD;AAEA,SAASI,kBAAkBA,CACzBN,IAAS,EACTG,KAA2B,EAC3BE,IAA0B,EAC1BH,KAAoB,EACpBK,SAA6B,EAC7B;EACA,IAAMC,IAAI,GAAGX,YAAA,CAAAY,YAAY,CAACT,IAAI,CAACU,IAAI,CAAC;EACpC,IAAI,CAACF,IAAI,EAAE;EAEX,IAAIL,KAAK,EAAEA,KAAK,CAACH,IAAI,EAAEO,SAAS,EAAEL,KAAK,CAAC;EAAA,IAAAS,SAAA,GAAAC,0BAAA,CAEtBJ,IAAI;IAAAK,KAAA;EAAA;IAAtB,KAAAF,SAAA,CAAAG,CAAA,MAAAD,KAAA,GAAAF,SAAA,CAAAI,CAAA,IAAAC,IAAA,GAAwB;MAAA,IAAbC,GAAG,GAAAJ,KAAA,CAAAK,KAAA;MACZ,IAAMC,OAAO,GAAGnB,IAAI,CAACiB,GAAG,CAAC;MAEzB,IAAIG,KAAK,CAACC,OAAO,CAACF,OAAO,CAAC,EAAE;QAC1B,KAAK,IAAIG,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGH,OAAO,CAACI,MAAM,EAAED,CAAC,EAAE,EAAE;UACvC,IAAME,KAAK,GAAGL,OAAO,CAACG,CAAC,CAAC;UACxB,IAAI,CAACE,KAAK,EAAE;UAEZjB,SAAS,CAACkB,IAAI,CAAC;YACbzB,IAAI,EAAJA,IAAI;YACJiB,GAAG,EAAHA,GAAG;YACHS,KAAK,EAAEJ;UACT,CAAC,CAAC;UAEFhB,kBAAkB,CAACkB,KAAK,EAAErB,KAAK,EAAEE,IAAI,EAAEH,KAAK,EAAEK,SAAS,CAAC;UAExDA,SAAS,CAACoB,GAAG,CAAC,CAAC;QACjB;MACF,CAAC,MAAM,IAAIR,OAAO,EAAE;QAClBZ,SAAS,CAACkB,IAAI,CAAC;UACbzB,IAAI,EAAJA,IAAI;UACJiB,GAAA,EAAAA;QACF,CAAC,CAAC;QAEFX,kBAAkB,CAACa,OAAO,EAAEhB,KAAK,EAAEE,IAAI,EAAEH,KAAK,EAAEK,SAAS,CAAC;QAE1DA,SAAS,CAACoB,GAAG,CAAC,CAAC;MACjB;IACF;EAAA,SAAAC,GAAA;IAAAjB,SAAA,CAAAkB,CAAA,CAAAD,GAAA;EAAA;IAAAjB,SAAA,CAAAmB,CAAA;EAAA;EAEA,IAAIzB,IAAI,EAAEA,IAAI,CAACL,IAAI,EAAEO,SAAS,EAAEL,KAAK,CAAC;AACxC"},"metadata":{},"sourceType":"script","externalDependencies":[]}