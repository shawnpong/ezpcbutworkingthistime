{"ast":null,"code":"\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"C:/Users/pongster/Documents/ezpcbutworkingthistime/FRONTEND/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _toConsumableArray = require(\"C:/Users/pongster/Documents/ezpcbutworkingthistime/FRONTEND/node_modules/@babel/runtime/helpers/toConsumableArray.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.VISITOR_KEYS = exports.NODE_PARENT_VALIDATIONS = exports.NODE_FIELDS = exports.FLIPPED_ALIAS_KEYS = exports.DEPRECATED_KEYS = exports.BUILDER_KEYS = exports.ALIAS_KEYS = void 0;\nexports.arrayOf = arrayOf;\nexports.arrayOfType = arrayOfType;\nexports.assertEach = assertEach;\nexports.assertNodeOrValueType = assertNodeOrValueType;\nexports.assertNodeType = assertNodeType;\nexports.assertOneOf = assertOneOf;\nexports.assertOptionalChainStart = assertOptionalChainStart;\nexports.assertShape = assertShape;\nexports.assertValueType = assertValueType;\nexports.chain = chain;\nexports.default = defineType;\nexports.defineAliasedType = defineAliasedType;\nexports.typeIs = typeIs;\nexports.validate = validate;\nexports.validateArrayOfType = validateArrayOfType;\nexports.validateOptional = validateOptional;\nexports.validateOptionalType = validateOptionalType;\nexports.validateType = validateType;\nvar _is = require(\"../validators/is\");\nvar _validate = require(\"../validators/validate\");\nvar VISITOR_KEYS = {};\nexports.VISITOR_KEYS = VISITOR_KEYS;\nvar ALIAS_KEYS = {};\nexports.ALIAS_KEYS = ALIAS_KEYS;\nvar FLIPPED_ALIAS_KEYS = {};\nexports.FLIPPED_ALIAS_KEYS = FLIPPED_ALIAS_KEYS;\nvar NODE_FIELDS = {};\nexports.NODE_FIELDS = NODE_FIELDS;\nvar BUILDER_KEYS = {};\nexports.BUILDER_KEYS = BUILDER_KEYS;\nvar DEPRECATED_KEYS = {};\nexports.DEPRECATED_KEYS = DEPRECATED_KEYS;\nvar NODE_PARENT_VALIDATIONS = {};\nexports.NODE_PARENT_VALIDATIONS = NODE_PARENT_VALIDATIONS;\nfunction getType(val) {\n  if (Array.isArray(val)) {\n    return \"array\";\n  } else if (val === null) {\n    return \"null\";\n  } else {\n    return typeof val;\n  }\n}\nfunction validate(validate) {\n  return {\n    validate: validate\n  };\n}\nfunction typeIs(typeName) {\n  return typeof typeName === \"string\" ? assertNodeType(typeName) : assertNodeType.apply(void 0, _toConsumableArray(typeName));\n}\nfunction validateType(typeName) {\n  return validate(typeIs(typeName));\n}\nfunction validateOptional(validate) {\n  return {\n    validate: validate,\n    optional: true\n  };\n}\nfunction validateOptionalType(typeName) {\n  return {\n    validate: typeIs(typeName),\n    optional: true\n  };\n}\nfunction arrayOf(elementType) {\n  return chain(assertValueType(\"array\"), assertEach(elementType));\n}\nfunction arrayOfType(typeName) {\n  return arrayOf(typeIs(typeName));\n}\nfunction validateArrayOfType(typeName) {\n  return validate(arrayOfType(typeName));\n}\nfunction assertEach(callback) {\n  function validator(node, key, val) {\n    if (!Array.isArray(val)) return;\n    for (var i = 0; i < val.length; i++) {\n      var subkey = \"\".concat(key, \"[\").concat(i, \"]\");\n      var v = val[i];\n      callback(node, subkey, v);\n      if (process.env.BABEL_TYPES_8_BREAKING) (0, _validate.validateChild)(node, subkey, v);\n    }\n  }\n  validator.each = callback;\n  return validator;\n}\nfunction assertOneOf() {\n  for (var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++) {\n    values[_key] = arguments[_key];\n  }\n  function validate(node, key, val) {\n    if (values.indexOf(val) < 0) {\n      throw new TypeError(\"Property \".concat(key, \" expected value to be one of \").concat(JSON.stringify(values), \" but got \").concat(JSON.stringify(val)));\n    }\n  }\n  validate.oneOf = values;\n  return validate;\n}\nfunction assertNodeType() {\n  for (var _len2 = arguments.length, types = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    types[_key2] = arguments[_key2];\n  }\n  function validate(node, key, val) {\n    var _iterator = _createForOfIteratorHelper(types),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var type = _step.value;\n        if ((0, _is.default)(type, val)) {\n          (0, _validate.validateChild)(node, key, val);\n          return;\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n    throw new TypeError(\"Property \".concat(key, \" of \").concat(node.type, \" expected node to be of a type \").concat(JSON.stringify(types), \" but instead got \").concat(JSON.stringify(val == null ? void 0 : val.type)));\n  }\n  validate.oneOfNodeTypes = types;\n  return validate;\n}\nfunction assertNodeOrValueType() {\n  for (var _len3 = arguments.length, types = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n    types[_key3] = arguments[_key3];\n  }\n  function validate(node, key, val) {\n    var _iterator2 = _createForOfIteratorHelper(types),\n      _step2;\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var type = _step2.value;\n        if (getType(val) === type || (0, _is.default)(type, val)) {\n          (0, _validate.validateChild)(node, key, val);\n          return;\n        }\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n    throw new TypeError(\"Property \".concat(key, \" of \").concat(node.type, \" expected node to be of a type \").concat(JSON.stringify(types), \" but instead got \").concat(JSON.stringify(val == null ? void 0 : val.type)));\n  }\n  validate.oneOfNodeOrValueTypes = types;\n  return validate;\n}\nfunction assertValueType(type) {\n  function validate(node, key, val) {\n    var valid = getType(val) === type;\n    if (!valid) {\n      throw new TypeError(\"Property \".concat(key, \" expected type of \").concat(type, \" but got \").concat(getType(val)));\n    }\n  }\n  validate.type = type;\n  return validate;\n}\nfunction assertShape(shape) {\n  function validate(node, key, val) {\n    var errors = [];\n    for (var _i = 0, _Object$keys = Object.keys(shape); _i < _Object$keys.length; _i++) {\n      var property = _Object$keys[_i];\n      try {\n        (0, _validate.validateField)(node, property, val[property], shape[property]);\n      } catch (error) {\n        if (error instanceof TypeError) {\n          errors.push(error.message);\n          continue;\n        }\n        throw error;\n      }\n    }\n    if (errors.length) {\n      throw new TypeError(\"Property \".concat(key, \" of \").concat(node.type, \" expected to have the following:\\n\").concat(errors.join(\"\\n\")));\n    }\n  }\n  validate.shapeOf = shape;\n  return validate;\n}\nfunction assertOptionalChainStart() {\n  function validate(node) {\n    var _current;\n    var current = node;\n    while (node) {\n      var _current2 = current,\n        type = _current2.type;\n      if (type === \"OptionalCallExpression\") {\n        if (current.optional) return;\n        current = current.callee;\n        continue;\n      }\n      if (type === \"OptionalMemberExpression\") {\n        if (current.optional) return;\n        current = current.object;\n        continue;\n      }\n      break;\n    }\n    throw new TypeError(\"Non-optional \".concat(node.type, \" must chain from an optional OptionalMemberExpression or OptionalCallExpression. Found chain from \").concat((_current = current) == null ? void 0 : _current.type));\n  }\n  return validate;\n}\nfunction chain() {\n  for (var _len4 = arguments.length, fns = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n    fns[_key4] = arguments[_key4];\n  }\n  function validate() {\n    var _iterator3 = _createForOfIteratorHelper(fns),\n      _step3;\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var fn = _step3.value;\n        fn.apply(void 0, arguments);\n      }\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n  }\n  validate.chainOf = fns;\n  if (fns.length >= 2 && \"type\" in fns[0] && fns[0].type === \"array\" && !(\"each\" in fns[1])) {\n    throw new Error(\"An assertValueType(\\\"array\\\") validator can only be followed by an assertEach(...) validator.\");\n  }\n  return validate;\n}\nvar validTypeOpts = [\"aliases\", \"builder\", \"deprecatedAlias\", \"fields\", \"inherits\", \"visitor\", \"validate\"];\nvar validFieldKeys = [\"default\", \"optional\", \"deprecated\", \"validate\"];\nvar store = {};\nfunction defineAliasedType() {\n  for (var _len5 = arguments.length, aliases = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n    aliases[_key5] = arguments[_key5];\n  }\n  return function (type) {\n    var _defined2;\n    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var defined = opts.aliases;\n    if (!defined) {\n      var _store$opts$inherits$, _defined;\n      if (opts.inherits) defined = (_store$opts$inherits$ = store[opts.inherits].aliases) == null ? void 0 : _store$opts$inherits$.slice();\n      (_defined = defined) != null ? _defined : defined = [];\n      opts.aliases = defined;\n    }\n    var additional = aliases.filter(function (a) {\n      return !defined.includes(a);\n    });\n    (_defined2 = defined).unshift.apply(_defined2, _toConsumableArray(additional));\n    defineType(type, opts);\n  };\n}\nfunction defineType(type) {\n  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var inherits = opts.inherits && store[opts.inherits] || {};\n  var fields = opts.fields;\n  if (!fields) {\n    fields = {};\n    if (inherits.fields) {\n      var keys = Object.getOwnPropertyNames(inherits.fields);\n      var _iterator4 = _createForOfIteratorHelper(keys),\n        _step4;\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var key = _step4.value;\n          var field = inherits.fields[key];\n          var def = field.default;\n          if (Array.isArray(def) ? def.length > 0 : def && typeof def === \"object\") {\n            throw new Error(\"field defaults can only be primitives or empty arrays currently\");\n          }\n          fields[key] = {\n            default: Array.isArray(def) ? [] : def,\n            optional: field.optional,\n            deprecated: field.deprecated,\n            validate: field.validate\n          };\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n    }\n  }\n  var visitor = opts.visitor || inherits.visitor || [];\n  var aliases = opts.aliases || inherits.aliases || [];\n  var builder = opts.builder || inherits.builder || opts.visitor || [];\n  for (var _i2 = 0, _Object$keys2 = Object.keys(opts); _i2 < _Object$keys2.length; _i2++) {\n    var k = _Object$keys2[_i2];\n    if (validTypeOpts.indexOf(k) === -1) {\n      throw new Error(\"Unknown type option \\\"\".concat(k, \"\\\" on \").concat(type));\n    }\n  }\n  if (opts.deprecatedAlias) {\n    DEPRECATED_KEYS[opts.deprecatedAlias] = type;\n  }\n  var _iterator5 = _createForOfIteratorHelper(visitor.concat(builder)),\n    _step5;\n  try {\n    for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n      var _key7 = _step5.value;\n      fields[_key7] = fields[_key7] || {};\n    }\n  } catch (err) {\n    _iterator5.e(err);\n  } finally {\n    _iterator5.f();\n  }\n  for (var _i3 = 0, _Object$keys3 = Object.keys(fields); _i3 < _Object$keys3.length; _i3++) {\n    var _key6 = _Object$keys3[_i3];\n    var _field = fields[_key6];\n    if (_field.default !== undefined && builder.indexOf(_key6) === -1) {\n      _field.optional = true;\n    }\n    if (_field.default === undefined) {\n      _field.default = null;\n    } else if (!_field.validate && _field.default != null) {\n      _field.validate = assertValueType(getType(_field.default));\n    }\n    for (var _i4 = 0, _Object$keys4 = Object.keys(_field); _i4 < _Object$keys4.length; _i4++) {\n      var _k = _Object$keys4[_i4];\n      if (validFieldKeys.indexOf(_k) === -1) {\n        throw new Error(\"Unknown field key \\\"\".concat(_k, \"\\\" on \").concat(type, \".\").concat(_key6));\n      }\n    }\n  }\n  VISITOR_KEYS[type] = opts.visitor = visitor;\n  BUILDER_KEYS[type] = opts.builder = builder;\n  NODE_FIELDS[type] = opts.fields = fields;\n  ALIAS_KEYS[type] = opts.aliases = aliases;\n  aliases.forEach(function (alias) {\n    FLIPPED_ALIAS_KEYS[alias] = FLIPPED_ALIAS_KEYS[alias] || [];\n    FLIPPED_ALIAS_KEYS[alias].push(type);\n  });\n  if (opts.validate) {\n    NODE_PARENT_VALIDATIONS[type] = opts.validate;\n  }\n  store[type] = opts;\n}","map":{"version":3,"names":["_is","require","_validate","VISITOR_KEYS","exports","ALIAS_KEYS","FLIPPED_ALIAS_KEYS","NODE_FIELDS","BUILDER_KEYS","DEPRECATED_KEYS","NODE_PARENT_VALIDATIONS","getType","val","Array","isArray","validate","typeIs","typeName","assertNodeType","apply","_toConsumableArray","validateType","validateOptional","optional","validateOptionalType","arrayOf","elementType","chain","assertValueType","assertEach","arrayOfType","validateArrayOfType","callback","validator","node","key","i","length","subkey","concat","v","process","env","BABEL_TYPES_8_BREAKING","validateChild","each","assertOneOf","_len","arguments","values","_key","indexOf","TypeError","JSON","stringify","oneOf","_len2","types","_key2","_iterator","_createForOfIteratorHelper","_step","s","n","done","type","value","default","err","e","f","oneOfNodeTypes","assertNodeOrValueType","_len3","_key3","_iterator2","_step2","oneOfNodeOrValueTypes","valid","assertShape","shape","errors","_i","_Object$keys","Object","keys","property","validateField","error","push","message","join","shapeOf","assertOptionalChainStart","_current","current","_current2","callee","object","_len4","fns","_key4","_iterator3","_step3","fn","chainOf","Error","validTypeOpts","validFieldKeys","store","defineAliasedType","_len5","aliases","_key5","_defined2","opts","undefined","defined","_store$opts$inherits$","_defined","inherits","slice","additional","filter","a","includes","unshift","defineType","fields","getOwnPropertyNames","_iterator4","_step4","field","def","deprecated","visitor","builder","_i2","_Object$keys2","k","deprecatedAlias","_iterator5","_step5","_i3","_Object$keys3","_i4","_Object$keys4","forEach","alias"],"sources":["C:\\Users\\pongster\\Documents\\ezpcbutworkingthistime\\FRONTEND\\node_modules\\@babel\\types\\src\\definitions\\utils.ts"],"sourcesContent":["import is from \"../validators/is\";\nimport { validateField, validateChild } from \"../validators/validate\";\nimport type * as t from \"..\";\n\nexport const VISITOR_KEYS: Record<string, string[]> = {};\nexport const ALIAS_KEYS: Partial<Record<NodeTypesWithoutComment, string[]>> =\n  {};\nexport const FLIPPED_ALIAS_KEYS: Record<string, NodeTypesWithoutComment[]> = {};\nexport const NODE_FIELDS: Record<string, FieldDefinitions> = {};\nexport const BUILDER_KEYS: Record<string, string[]> = {};\nexport const DEPRECATED_KEYS: Record<string, NodeTypesWithoutComment> = {};\nexport const NODE_PARENT_VALIDATIONS: Record<string, Validator> = {};\n\nfunction getType(val: any) {\n  if (Array.isArray(val)) {\n    return \"array\";\n  } else if (val === null) {\n    return \"null\";\n  } else {\n    return typeof val;\n  }\n}\n\ntype NodeTypesWithoutComment = t.Node[\"type\"] | keyof t.Aliases;\n\ntype NodeTypes = NodeTypesWithoutComment | t.Comment[\"type\"];\n\ntype PrimitiveTypes = ReturnType<typeof getType>;\n\ntype FieldDefinitions = {\n  [x: string]: FieldOptions;\n};\n\ntype DefineTypeOpts = {\n  fields?: FieldDefinitions;\n  visitor?: Array<string>;\n  aliases?: Array<string>;\n  builder?: Array<string>;\n  inherits?: NodeTypes;\n  deprecatedAlias?: string;\n  validate?: Validator;\n};\n\nexport type Validator = (\n  | { type: PrimitiveTypes }\n  | { each: Validator }\n  | { chainOf: Validator[] }\n  | { oneOf: any[] }\n  | { oneOfNodeTypes: NodeTypes[] }\n  | { oneOfNodeOrValueTypes: (NodeTypes | PrimitiveTypes)[] }\n  | { shapeOf: { [x: string]: FieldOptions } }\n  | {}\n) &\n  ((node: t.Node, key: string, val: any) => void);\n\nexport type FieldOptions = {\n  default?: string | number | boolean | [];\n  optional?: boolean;\n  deprecated?: boolean;\n  validate?: Validator;\n};\n\nexport function validate(validate: Validator): FieldOptions {\n  return { validate };\n}\n\nexport function typeIs(typeName: NodeTypes | NodeTypes[]) {\n  return typeof typeName === \"string\"\n    ? assertNodeType(typeName)\n    : assertNodeType(...typeName);\n}\n\nexport function validateType(typeName: NodeTypes | NodeTypes[]) {\n  return validate(typeIs(typeName));\n}\n\nexport function validateOptional(validate: Validator): FieldOptions {\n  return { validate, optional: true };\n}\n\nexport function validateOptionalType(\n  typeName: NodeTypes | NodeTypes[],\n): FieldOptions {\n  return { validate: typeIs(typeName), optional: true };\n}\n\nexport function arrayOf(elementType: Validator): Validator {\n  return chain(assertValueType(\"array\"), assertEach(elementType));\n}\n\nexport function arrayOfType(typeName: NodeTypes | NodeTypes[]) {\n  return arrayOf(typeIs(typeName));\n}\n\nexport function validateArrayOfType(typeName: NodeTypes | NodeTypes[]) {\n  return validate(arrayOfType(typeName));\n}\n\nexport function assertEach(callback: Validator): Validator {\n  function validator(node: t.Node, key: string, val: any) {\n    if (!Array.isArray(val)) return;\n\n    for (let i = 0; i < val.length; i++) {\n      const subkey = `${key}[${i}]`;\n      const v = val[i];\n      callback(node, subkey, v);\n      if (process.env.BABEL_TYPES_8_BREAKING) validateChild(node, subkey, v);\n    }\n  }\n  validator.each = callback;\n  return validator;\n}\n\nexport function assertOneOf(...values: Array<any>): Validator {\n  function validate(node: any, key: string, val: any) {\n    if (values.indexOf(val) < 0) {\n      throw new TypeError(\n        `Property ${key} expected value to be one of ${JSON.stringify(\n          values,\n        )} but got ${JSON.stringify(val)}`,\n      );\n    }\n  }\n\n  validate.oneOf = values;\n\n  return validate;\n}\n\nexport function assertNodeType(...types: NodeTypes[]): Validator {\n  function validate(node: t.Node, key: string, val: any) {\n    for (const type of types) {\n      if (is(type, val)) {\n        validateChild(node, key, val);\n        return;\n      }\n    }\n\n    throw new TypeError(\n      `Property ${key} of ${\n        node.type\n      } expected node to be of a type ${JSON.stringify(\n        types,\n      )} but instead got ${JSON.stringify(val?.type)}`,\n    );\n  }\n\n  validate.oneOfNodeTypes = types;\n\n  return validate;\n}\n\nexport function assertNodeOrValueType(\n  ...types: (NodeTypes | PrimitiveTypes)[]\n): Validator {\n  function validate(node: t.Node, key: string, val: any) {\n    for (const type of types) {\n      if (getType(val) === type || is(type, val)) {\n        validateChild(node, key, val);\n        return;\n      }\n    }\n\n    throw new TypeError(\n      `Property ${key} of ${\n        node.type\n      } expected node to be of a type ${JSON.stringify(\n        types,\n      )} but instead got ${JSON.stringify(val?.type)}`,\n    );\n  }\n\n  validate.oneOfNodeOrValueTypes = types;\n\n  return validate;\n}\n\nexport function assertValueType(type: PrimitiveTypes): Validator {\n  function validate(node: t.Node, key: string, val: any) {\n    const valid = getType(val) === type;\n\n    if (!valid) {\n      throw new TypeError(\n        `Property ${key} expected type of ${type} but got ${getType(val)}`,\n      );\n    }\n  }\n\n  validate.type = type;\n\n  return validate;\n}\n\nexport function assertShape(shape: { [x: string]: FieldOptions }): Validator {\n  function validate(node: t.Node, key: string, val: any) {\n    const errors = [];\n    for (const property of Object.keys(shape)) {\n      try {\n        validateField(node, property, val[property], shape[property]);\n      } catch (error) {\n        if (error instanceof TypeError) {\n          errors.push(error.message);\n          continue;\n        }\n        throw error;\n      }\n    }\n    if (errors.length) {\n      throw new TypeError(\n        `Property ${key} of ${\n          node.type\n        } expected to have the following:\\n${errors.join(\"\\n\")}`,\n      );\n    }\n  }\n\n  validate.shapeOf = shape;\n\n  return validate;\n}\n\nexport function assertOptionalChainStart(): Validator {\n  function validate(node: t.Node) {\n    let current = node;\n    while (node) {\n      const { type } = current;\n      if (type === \"OptionalCallExpression\") {\n        if (current.optional) return;\n        current = current.callee;\n        continue;\n      }\n\n      if (type === \"OptionalMemberExpression\") {\n        if (current.optional) return;\n        current = current.object;\n        continue;\n      }\n\n      break;\n    }\n\n    throw new TypeError(\n      `Non-optional ${node.type} must chain from an optional OptionalMemberExpression or OptionalCallExpression. Found chain from ${current?.type}`,\n    );\n  }\n\n  return validate;\n}\n\nexport function chain(...fns: Array<Validator>): Validator {\n  function validate(...args: Parameters<Validator>) {\n    for (const fn of fns) {\n      fn(...args);\n    }\n  }\n  validate.chainOf = fns;\n\n  if (\n    fns.length >= 2 &&\n    \"type\" in fns[0] &&\n    fns[0].type === \"array\" &&\n    !(\"each\" in fns[1])\n  ) {\n    throw new Error(\n      `An assertValueType(\"array\") validator can only be followed by an assertEach(...) validator.`,\n    );\n  }\n\n  return validate;\n}\n\nconst validTypeOpts = [\n  \"aliases\",\n  \"builder\",\n  \"deprecatedAlias\",\n  \"fields\",\n  \"inherits\",\n  \"visitor\",\n  \"validate\",\n];\nconst validFieldKeys = [\"default\", \"optional\", \"deprecated\", \"validate\"];\n\nconst store = {} as Record<string, DefineTypeOpts>;\n\n// Wraps defineType to ensure these aliases are included.\nexport function defineAliasedType(...aliases: string[]) {\n  return (type: string, opts: DefineTypeOpts = {}) => {\n    let defined = opts.aliases;\n    if (!defined) {\n      if (opts.inherits) defined = store[opts.inherits].aliases?.slice();\n      defined ??= [];\n      opts.aliases = defined;\n    }\n    const additional = aliases.filter(a => !defined.includes(a));\n    defined.unshift(...additional);\n    defineType(type, opts);\n  };\n}\n\nexport default function defineType(type: string, opts: DefineTypeOpts = {}) {\n  const inherits = (opts.inherits && store[opts.inherits]) || {};\n\n  let fields = opts.fields;\n  if (!fields) {\n    fields = {};\n    if (inherits.fields) {\n      const keys = Object.getOwnPropertyNames(inherits.fields);\n      for (const key of keys) {\n        const field = inherits.fields[key];\n        const def = field.default;\n        if (\n          Array.isArray(def) ? def.length > 0 : def && typeof def === \"object\"\n        ) {\n          throw new Error(\n            \"field defaults can only be primitives or empty arrays currently\",\n          );\n        }\n        fields[key] = {\n          default: Array.isArray(def) ? [] : def,\n          optional: field.optional,\n          deprecated: field.deprecated,\n          validate: field.validate,\n        };\n      }\n    }\n  }\n\n  const visitor: Array<string> = opts.visitor || inherits.visitor || [];\n  const aliases: Array<string> = opts.aliases || inherits.aliases || [];\n  const builder: Array<string> =\n    opts.builder || inherits.builder || opts.visitor || [];\n\n  for (const k of Object.keys(opts)) {\n    if (validTypeOpts.indexOf(k) === -1) {\n      throw new Error(`Unknown type option \"${k}\" on ${type}`);\n    }\n  }\n\n  if (opts.deprecatedAlias) {\n    DEPRECATED_KEYS[opts.deprecatedAlias] = type as NodeTypesWithoutComment;\n  }\n\n  // ensure all field keys are represented in `fields`\n  for (const key of visitor.concat(builder)) {\n    fields[key] = fields[key] || {};\n  }\n\n  for (const key of Object.keys(fields)) {\n    const field = fields[key];\n\n    if (field.default !== undefined && builder.indexOf(key) === -1) {\n      field.optional = true;\n    }\n    if (field.default === undefined) {\n      field.default = null;\n    } else if (!field.validate && field.default != null) {\n      field.validate = assertValueType(getType(field.default));\n    }\n\n    for (const k of Object.keys(field)) {\n      if (validFieldKeys.indexOf(k) === -1) {\n        throw new Error(`Unknown field key \"${k}\" on ${type}.${key}`);\n      }\n    }\n  }\n\n  VISITOR_KEYS[type] = opts.visitor = visitor;\n  BUILDER_KEYS[type] = opts.builder = builder;\n  NODE_FIELDS[type] = opts.fields = fields;\n  ALIAS_KEYS[type as NodeTypesWithoutComment] = opts.aliases = aliases;\n  aliases.forEach(alias => {\n    FLIPPED_ALIAS_KEYS[alias] = FLIPPED_ALIAS_KEYS[alias] || [];\n    FLIPPED_ALIAS_KEYS[alias].push(type as NodeTypesWithoutComment);\n  });\n\n  if (opts.validate) {\n    NODE_PARENT_VALIDATIONS[type] = opts.validate;\n  }\n\n  store[type] = opts;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}