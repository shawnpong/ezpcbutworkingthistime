{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = cloneNode;\nvar _definitions = require(\"../definitions\");\nvar _generated = require(\"../validators/generated\");\nvar has = Function.call.bind(Object.prototype.hasOwnProperty);\nfunction cloneIfNode(obj, deep, withoutLoc, commentsCache) {\n  if (obj && typeof obj.type === \"string\") {\n    return cloneNodeInternal(obj, deep, withoutLoc, commentsCache);\n  }\n  return obj;\n}\nfunction cloneIfNodeOrArray(obj, deep, withoutLoc, commentsCache) {\n  if (Array.isArray(obj)) {\n    return obj.map(function (node) {\n      return cloneIfNode(node, deep, withoutLoc, commentsCache);\n    });\n  }\n  return cloneIfNode(obj, deep, withoutLoc, commentsCache);\n}\nfunction cloneNode(node) {\n  var deep = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  var withoutLoc = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  return cloneNodeInternal(node, deep, withoutLoc, new Map());\n}\nfunction cloneNodeInternal(node) {\n  var deep = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  var withoutLoc = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var commentsCache = arguments.length > 3 ? arguments[3] : undefined;\n  if (!node) return node;\n  var type = node.type;\n  var newNode = {\n    type: node.type\n  };\n  if ((0, _generated.isIdentifier)(node)) {\n    newNode.name = node.name;\n    if (has(node, \"optional\") && typeof node.optional === \"boolean\") {\n      newNode.optional = node.optional;\n    }\n    if (has(node, \"typeAnnotation\")) {\n      newNode.typeAnnotation = deep ? cloneIfNodeOrArray(node.typeAnnotation, true, withoutLoc, commentsCache) : node.typeAnnotation;\n    }\n  } else if (!has(_definitions.NODE_FIELDS, type)) {\n    throw new Error(\"Unknown node type: \\\"\".concat(type, \"\\\"\"));\n  } else {\n    for (var _i = 0, _Object$keys = Object.keys(_definitions.NODE_FIELDS[type]); _i < _Object$keys.length; _i++) {\n      var field = _Object$keys[_i];\n      if (has(node, field)) {\n        if (deep) {\n          newNode[field] = (0, _generated.isFile)(node) && field === \"comments\" ? maybeCloneComments(node.comments, deep, withoutLoc, commentsCache) : cloneIfNodeOrArray(node[field], true, withoutLoc, commentsCache);\n        } else {\n          newNode[field] = node[field];\n        }\n      }\n    }\n  }\n  if (has(node, \"loc\")) {\n    if (withoutLoc) {\n      newNode.loc = null;\n    } else {\n      newNode.loc = node.loc;\n    }\n  }\n  if (has(node, \"leadingComments\")) {\n    newNode.leadingComments = maybeCloneComments(node.leadingComments, deep, withoutLoc, commentsCache);\n  }\n  if (has(node, \"innerComments\")) {\n    newNode.innerComments = maybeCloneComments(node.innerComments, deep, withoutLoc, commentsCache);\n  }\n  if (has(node, \"trailingComments\")) {\n    newNode.trailingComments = maybeCloneComments(node.trailingComments, deep, withoutLoc, commentsCache);\n  }\n  if (has(node, \"extra\")) {\n    newNode.extra = Object.assign({}, node.extra);\n  }\n  return newNode;\n}\nfunction maybeCloneComments(comments, deep, withoutLoc, commentsCache) {\n  if (!comments || !deep) {\n    return comments;\n  }\n  return comments.map(function (comment) {\n    var cache = commentsCache.get(comment);\n    if (cache) return cache;\n    var type = comment.type,\n      value = comment.value,\n      loc = comment.loc;\n    var ret = {\n      type: type,\n      value: value,\n      loc: loc\n    };\n    if (withoutLoc) {\n      ret.loc = null;\n    }\n    commentsCache.set(comment, ret);\n    return ret;\n  });\n}","map":{"version":3,"names":["_definitions","require","_generated","has","Function","call","bind","Object","prototype","hasOwnProperty","cloneIfNode","obj","deep","withoutLoc","commentsCache","type","cloneNodeInternal","cloneIfNodeOrArray","Array","isArray","map","node","cloneNode","arguments","length","undefined","Map","newNode","isIdentifier","name","optional","typeAnnotation","NODE_FIELDS","Error","concat","_i","_Object$keys","keys","field","isFile","maybeCloneComments","comments","loc","leadingComments","innerComments","trailingComments","extra","assign","comment","cache","get","value","ret","set"],"sources":["C:\\Users\\pongster\\Documents\\ezpcbutworkingthistime\\FRONTEND\\node_modules\\@babel\\types\\src\\clone\\cloneNode.ts"],"sourcesContent":["import { NODE_FIELDS } from \"../definitions\";\nimport type * as t from \"..\";\nimport { isFile, isIdentifier } from \"../validators/generated\";\n\nconst has = Function.call.bind(Object.prototype.hasOwnProperty);\n\ntype CommentCache = Map<t.Comment, t.Comment>;\n\n// This function will never be called for comments, only for real nodes.\nfunction cloneIfNode(\n  obj: t.Node | undefined | null,\n  deep: boolean,\n  withoutLoc: boolean,\n  commentsCache: CommentCache,\n) {\n  if (obj && typeof obj.type === \"string\") {\n    return cloneNodeInternal(obj, deep, withoutLoc, commentsCache);\n  }\n\n  return obj;\n}\n\nfunction cloneIfNodeOrArray(\n  obj: t.Node | undefined | null | (t.Node | undefined | null)[],\n  deep: boolean,\n  withoutLoc: boolean,\n  commentsCache: CommentCache,\n) {\n  if (Array.isArray(obj)) {\n    return obj.map(node => cloneIfNode(node, deep, withoutLoc, commentsCache));\n  }\n  return cloneIfNode(obj, deep, withoutLoc, commentsCache);\n}\n\n/**\n * Create a clone of a `node` including only properties belonging to the node.\n * If the second parameter is `false`, cloneNode performs a shallow clone.\n * If the third parameter is true, the cloned nodes exclude location properties.\n */\nexport default function cloneNode<T extends t.Node>(\n  node: T,\n  deep: boolean = true,\n  withoutLoc: boolean = false,\n): T {\n  return cloneNodeInternal(node, deep, withoutLoc, new Map());\n}\n\nfunction cloneNodeInternal<T extends t.Node>(\n  node: T,\n  deep: boolean = true,\n  withoutLoc: boolean = false,\n  commentsCache: CommentCache,\n): T {\n  if (!node) return node;\n\n  const { type } = node;\n  const newNode: any = { type: node.type };\n\n  // Special-case identifiers since they are the most cloned nodes.\n  if (isIdentifier(node)) {\n    newNode.name = node.name;\n\n    if (has(node, \"optional\") && typeof node.optional === \"boolean\") {\n      newNode.optional = node.optional;\n    }\n\n    if (has(node, \"typeAnnotation\")) {\n      newNode.typeAnnotation = deep\n        ? cloneIfNodeOrArray(\n            node.typeAnnotation,\n            true,\n            withoutLoc,\n            commentsCache,\n          )\n        : node.typeAnnotation;\n    }\n  } else if (!has(NODE_FIELDS, type)) {\n    throw new Error(`Unknown node type: \"${type}\"`);\n  } else {\n    for (const field of Object.keys(NODE_FIELDS[type])) {\n      if (has(node, field)) {\n        if (deep) {\n          newNode[field] =\n            isFile(node) && field === \"comments\"\n              ? maybeCloneComments(\n                  node.comments,\n                  deep,\n                  withoutLoc,\n                  commentsCache,\n                )\n              : cloneIfNodeOrArray(\n                  // @ts-expect-error node[field] has been guarded by has check\n                  node[field],\n                  true,\n                  withoutLoc,\n                  commentsCache,\n                );\n        } else {\n          newNode[field] =\n            // @ts-expect-error node[field] has been guarded by has check\n            node[field];\n        }\n      }\n    }\n  }\n\n  if (has(node, \"loc\")) {\n    if (withoutLoc) {\n      newNode.loc = null;\n    } else {\n      newNode.loc = node.loc;\n    }\n  }\n  if (has(node, \"leadingComments\")) {\n    newNode.leadingComments = maybeCloneComments(\n      node.leadingComments,\n      deep,\n      withoutLoc,\n      commentsCache,\n    );\n  }\n  if (has(node, \"innerComments\")) {\n    newNode.innerComments = maybeCloneComments(\n      node.innerComments,\n      deep,\n      withoutLoc,\n      commentsCache,\n    );\n  }\n  if (has(node, \"trailingComments\")) {\n    newNode.trailingComments = maybeCloneComments(\n      node.trailingComments,\n      deep,\n      withoutLoc,\n      commentsCache,\n    );\n  }\n  if (has(node, \"extra\")) {\n    newNode.extra = {\n      ...node.extra,\n    };\n  }\n\n  return newNode;\n}\n\nfunction maybeCloneComments<T extends t.Comment>(\n  comments: ReadonlyArray<T> | null,\n  deep: boolean,\n  withoutLoc: boolean,\n  commentsCache: Map<T, T>,\n): ReadonlyArray<T> | null {\n  if (!comments || !deep) {\n    return comments;\n  }\n  return comments.map(comment => {\n    const cache = commentsCache.get(comment);\n    if (cache) return cache;\n\n    const { type, value, loc } = comment;\n\n    const ret = { type, value, loc } as T;\n    if (withoutLoc) {\n      ret.loc = null;\n    }\n\n    commentsCache.set(comment, ret);\n\n    return ret;\n  });\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}